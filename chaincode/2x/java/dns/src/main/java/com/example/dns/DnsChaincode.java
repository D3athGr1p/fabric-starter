/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.example.dns;


import com.example.dns.ledger.*;
import com.owlike.genson.Genson;
import io.github.cdimascio.dotenv.Dotenv;
import org.hyperledger.fabric.contract.Context;
import org.hyperledger.fabric.contract.ContractInterface;
import org.hyperledger.fabric.contract.ContractRouter;
import org.hyperledger.fabric.contract.annotation.*;
import org.hyperledger.fabric.shim.*;
import org.hyperledger.fabric.shim.ledger.KeyValue;
import org.hyperledger.fabric.shim.ledger.QueryResultsIterator;

import java.io.File;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.util.*;

@Contract(
        name = "DnsChaincode",
        info = @Info(
                title = "DnsChaincode contract",
                description = "Store ip resolving information of orgs in a newtwork",
                version = "1.0",
                license = @License(
                        name = "MIT")
        )
)

@Default
public final class DnsChaincode implements ContractInterface {

    private final Genson genson = new Genson();

    @Transaction(intent = Transaction.TYPE.SUBMIT)
    public void registerOrgByParams(final Context ctx, String orgId, String domain, String orgIp, String peerPort, String wwwPort, String peerName) {
        Org org = new Org(orgId, domain, orgIp, peerPort, wwwPort, peerName);
        String serialized = genson.serialize(org);
        System.out.println("Org object got by params:" + serialized);
        this.registerOrg(ctx, serialized);
    }

    @Transaction(intent = Transaction.TYPE.SUBMIT)
    public void registerOrg(final Context ctx, final String orgSerialized) {
        System.out.println("registerOrg: " + orgSerialized);

        Org orgObj = genson.deserialize(orgSerialized, Org.class);
        System.out.println("org : " + orgObj);


        if (orgObj.getOrgId() == null || orgObj.getDomain() == null || (orgObj.getPeerPort() == null && orgObj.getPeers() == null)) {
            throw new ChaincodeException("orgId, domain and (peerPort or peers) properties are required");
        }

        String peerName = orgObj.getPeerName() != null ? orgObj.getPeerName() : "peer0";

        List<DnsRecord> dnsNames = new ArrayList<>();
        if (orgObj.getPeerPort() != null) {
            String peerDNS = peerName + "-" + orgObj.getOrgId() + "." + orgObj.getDomain(); //TODO: remove dns from chaincode
            dnsNames.add(new DnsRecord(orgObj.getOrgIp(), peerDNS));
        } else if (orgObj.getPeers() != null) {
            /* TODO             Arrays.stream(orgObj.getPeers()).map(peer->{
            const peersDns = _.map(_.keys(peers), peersPeerName = > new Object({
                    ip:peers[peersPeerName].ip,
                    dns: `$ {
                peersPeerName
            } -$ {
                orgNameDomain
            }`
            }))
            dnsNames.push(...peersDns)
            logger.debug('Pushed peers dns:', dnsNames)*/
        }

        storeDnsInfo(ctx, dnsNames);

        SortedMap<String, Peer> peersMap = new TreeMap<>() {{
            put(peerName, new Peer(orgObj.getOrgIp(), orgObj.getPeerPort()));
        }};
        Org normalizedOrg = new Org(orgObj.getOrgId(), orgObj.getDomain(), orgObj.getOrgIp(), orgObj.getPeerPort(), orgObj.getWwwPort(), null,
                orgObj.getWwwIp(), peersMap);

        storeObjInLedgerMap(ctx, normalizedOrg, "orgs");
    }


    @Transaction(intent = Transaction.TYPE.SUBMIT)
    public void registerOrdererByParams(final Context ctx, String ordererName, String domain, String ordererPort, String ordererIp, String wwwPort) {
        Orderer orderer = new Orderer(ordererName, domain, ordererIp, ordererPort, wwwPort, ordererIp);
        String serialized = genson.serialize(orderer);
        System.out.println("Orderer object got by params:" + serialized);
        this.registerOrderer(ctx, serialized);
    }


    @Transaction(intent = Transaction.TYPE.SUBMIT)
    public void registerOrderer(final Context ctx, final String ordererSerialized) {
        Orderer ordererObj = genson.deserialize(ordererSerialized, Orderer.class);


        if (ordererObj.getOrdererName() == null || ordererObj.getDomain() == null || ordererObj.getOrdererPort() == null) {
            throw new ChaincodeException("ordererName, domain and ordererPort properties are required");
        }

        if (ordererObj.getOrdererIp() != null) {
            List<DnsRecord> dnsNames = new ArrayList<>();
            String ordererDNS = ordererObj.getOrdererName() + "." + ordererObj.getDomain(); //TODO: remove dns from chaincode
            dnsNames.add(new DnsRecord(ordererObj.getOrdererIp(), ordererDNS));
            storeDnsInfo(ctx, dnsNames);
        }

        storeObjInLedgerMap(ctx, ordererObj, "osn");

    }


    private void storeDnsInfo(Context ctx, List<DnsRecord> dnsNames) {

        SortedMap<String, String> storedDnsRecords = getMapFromLedger(ctx, "dns");

        dnsNames.stream().forEach(dnsRecord -> {
            String dnsLine = storedDnsRecords.containsKey(dnsRecord.getIp()) ? storedDnsRecords.get(dnsRecord.getIp()) : "";
            if (!dnsLine.contains(" " + dnsRecord.getRecord())) {
                dnsLine = dnsLine + " " + dnsRecord.getRecord();
                storedDnsRecords.put(dnsRecord.getIp(), dnsLine);
            }
        });

        this.put(ctx, "dns", genson.serialize(storedDnsRecords));
    }

    private <T extends LedgerMapObject> void storeObjInLedgerMap(Context ctx, T obj, String ledgerKey) {
        SortedMap<String, T> orgs = getMapFromLedger(ctx, ledgerKey);

        orgs.put(obj.objectNameInMap(), obj);
        this.put(ctx, ledgerKey, genson.serialize(orgs));
    }


    @Transaction(intent = Transaction.TYPE.SUBMIT)
    public void put(final Context ctx, final String key, final String value) {
//        if (key == null || value == null) {
//            throw new ChaincodeException("Key and Value should not be empty");
//        }
        ChaincodeStub stub = ctx.getStub();
        System.out.println("put Value:" + value);
        stub.putStringState(key, value);
    }


    @Transaction(intent = Transaction.TYPE.EVALUATE)
    public String get(final Context ctx, final String key) {
        ChaincodeStub stub = ctx.getStub();

        String stringState = stub.getStringState(key);
        System.out.println("get stringState:" + stringState);
        return stringState;
    }

    @Transaction(intent = Transaction.TYPE.EVALUATE)
    public String range(final Context ctx) {
        ChaincodeStub stub = ctx.getStub();
        QueryResultsIterator<KeyValue> stateByRange = stub.getStateByRange("", "");

        Map<String, Object> result = new LinkedHashMap<>();
        if (stateByRange != null) {
            stateByRange.forEach(keyValue -> {
                System.out.println("range key:" + keyValue.getKey());
//                System.out.println("range Value:" + keyValue.getStringValue());
                Object value = keyValue.getStringValue();
                try {
                    value = genson.deserialize(keyValue.getStringValue(), Object.class);
                } catch (Exception e) {
                    System.out.println("Error deserialising nested map:" + keyValue.getStringValue() + ":" + e.getMessage());
                }
                result.put(keyValue.getKey(), value);
            });
        }
        return genson.serialize(result);
    }

    private <T> SortedMap<String, T> getMapFromLedger(final Context ctx, String key) {
        String serialized = get(ctx, key);
        SortedMap<String, T> map = genson.deserialize(serialized, TreeMap.class);
        if (map == null) {
            map = new TreeMap<>();
        }
        return map;
    }


    public static void main(String[] args) throws Exception {

        Dotenv dotenv = Dotenv.configure().ignoreIfMissing().load();
        if (System.getenv("CHAINCODE_ENV_FILE") != null) {
            File chaincodeEnvFile = new File(System.getenv("CHAINCODE_ENV_FILE"));
            dotenv = Dotenv.configure()
                    .directory(chaincodeEnvFile.getParent())
                    .filename(chaincodeEnvFile.getName())
                    .load();
        }

        ChaincodeServerProperties chaincodeServerProperties = new ChaincodeServerProperties();

        final String chaincodeServerPort = dotenv.get("CHAINCODE_BIND_ADDRESS");
        if (chaincodeServerPort == null || chaincodeServerPort.isEmpty()) {
            System.out.println("Starting in docker mode. For external mode set CHAINCODE_BIND_ADDRESS (e.g 0.0.0.0:9999).");
            ContractRouter.main(args);
            return;
//            throw new IOException("chaincode server port not defined in system env. for example 'CHAINCODE_BIND_ADDRESS=0.0.0.0:9999'");
        }

        String[] bindAddressParts = chaincodeServerPort.split(":");
        final String host=bindAddressParts[0];
        final int port = Integer.parseInt(bindAddressParts[1]);
//        chaincodeServerProperties.setPortChaincodeServer(port);
        InetSocketAddress unresolved = new InetSocketAddress(host ,port);

        chaincodeServerProperties.setServerAddress(unresolved);

        final String coreChaincodeIdName = dotenv.get("PACKAGE_ID");
        if (coreChaincodeIdName == null || coreChaincodeIdName.isEmpty()) {
            throw new IOException("Chaincode package id is not defined in system env. for example 'PACKAGE_ID=externalcc:06d1d324e858751d6eb4211885e9fd9ff74b62cb4ffda2242277fac95d467033'");
        }

        boolean tlsEnabled = Boolean.parseBoolean(dotenv.get("CORE_PEER_TLS_ENABLED"));
        if (tlsEnabled) {
            // String tlsClientRootCertPath = System.getenv(CORE_PEER_TLS_ROOTCERT_FILE);
            String tlsClientKeyFile = System.getenv("ENV_TLS_CLIENT_KEY_FILE");
            String tlsClientCertFile = System.getenv("ENV_TLS_CLIENT_CERT_FILE");

            // set values on the server properties
            chaincodeServerProperties.setTlsEnabled(true);
            chaincodeServerProperties.setKeyFile(tlsClientKeyFile);
            chaincodeServerProperties.setKeyCertChainFile(tlsClientCertFile);
        }

        ContractRouter contractRouter = new ContractRouter(new String[]{"-i", coreChaincodeIdName});
        ChaincodeServer chaincodeServer = new NettyChaincodeServer(contractRouter, chaincodeServerProperties);

        contractRouter.startRouterWithChaincodeServer(chaincodeServer);
    }

}
